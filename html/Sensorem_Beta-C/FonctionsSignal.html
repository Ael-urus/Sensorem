<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1, minimum-scale=1" name="viewport"/>
    <meta content="pdoc 0.10.0" name="generator"/>
    <title>Sensorem_Beta-C.FonctionsSignal API documentation</title>
    <meta content="Created on Wed Apr 15 11:10:34 2020 …" name="description"/>
    <link as="style" crossorigin href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
          integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" rel="preload stylesheet">
    <link as="style" crossorigin
          href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
          integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" rel="preload stylesheet">
    <link as="style" crossorigin href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css"
          rel="stylesheet preload">
    <style>
        :root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}
    </style>
    <style media="screen and (min-width: 700px)">
        @media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}
    </style>
    <style media="print">
        @media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}
    </style>
    <script crossorigin defer integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8="
            src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
    <script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
    <article id="content">
        <header>
            <h1 class="title">Module <code>Sensorem_Beta-C.FonctionsSignal</code></h1>
        </header>
        <section id="section-intro">
            <p>Created on Wed Apr 15 11:10:34 2020</p>
            <p>@author: Aelurus</p>
            <details class="source">
                <summary>
                    <span>Expand source code</span>
                </summary>
                <pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Wed Apr 15 11:10:34 2020

@author: Aelurus
&#34;&#34;&#34;
try:
    from statistics import mean, pstdev
    from doctest import testmod
    import csv
    # from reportlab.graphics.widgets.markers import makeMarker
    # from reportlab.graphics.charts.textlabels import Label

except Exception as e:
    print(e)
    input(&#39;***&#39;)


# 1

def version():
    &#34;&#34;&#34;Retourne le numéro de version du logiciel
    &#34;&#34;&#34;
    # definition et passage du numéro de version du traitement
    # version = str(&#34; (0.4.3 Bêta_c)&#34;)
    return str(&#34; (0.4.3 Bêta_c)&#34;)


def prep_donnees_graph(donnees):
    &#34;&#34;&#34;
    retourne une liste d&#39;éléments en listes d&#39;éléments incrémentée,
    &gt;&gt;&gt; prep_donnees_graph([1,2,3,4,5])
    [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]]
    &#34;&#34;&#34;
    return [[i, donnee] for i, donnee in enumerate(donnees)]


######
def traitement_signal(data):
    &#34;&#34;&#34;Fonction générale qui appel les traitements des données, pour le capteur à raccorder

    &#34;&#34;&#34;
    # identification des paliers
    values_sep = sep_values(data)
    paliers_find, plage_len_find, nb_values, values_sep = info_values(values_sep)
    paliers = make_paliers(paliers_find, plage_len_find)
    values_sep_paliers = paliers_values_sep(values_sep, nb_values, paliers)
    return values_sep_paliers, data, values_sep, paliers_find


def traitement_signal2(data):
    &#34;&#34;&#34;
    TBC
    &#34;&#34;&#34;
    # identification des paliers
    values_sep = sep_values2(data)
    paliers_find, plage_len_find, nb_values, values_sep = info_values(values_sep)
    paliers = make_paliers(paliers_find, plage_len_find)
    values_sep_paliers = paliers_values_sep(values_sep, nb_values, paliers)
    return values_sep_paliers, data, values_sep, paliers_find


# recuperation des valeurs à traiter
def readColCSV1(fichier, sep, n):
    &#34;&#34;&#34;
    Lecture complete du fichier
    Pour les deux premiers paramètres attention à bien utiliser les guillements
    car la fonction attend des chaines de caractères.
    fichier &lt;str&gt; : Le nom du fichier -&gt; &#34;mon_fichier.csv&#34;
    sep &lt;str&gt; : Le séparateur des colonnes par exemple -&gt; &#34;;&#34;
    n &lt;int&gt; : Le numéro de la colonne à lire
    &#34;&#34;&#34;
    file = open(fichier, &#34;r&#34;)
    reader = csv.reader(file, delimiter=sep)
    col = []
    for row in reader:
        # if row[n] == &#34;Invalid&#34;: row[n]=float(0.0)
        if n &lt; len(row) and row[n] == &#39;Invalid&#39;:
            row[n] = float(0.0)
            # BGU supress ? car row[n] peut planter (or try/except), notamment sur une ligne vide
        try:
            notation_point = row[n].replace(&#34;,&#34;, &#34;.&#34;)
            col.append(float(notation_point))
        # except Exception as e:
        except :
            if n &lt; len(row) and row[n] == &#39;Invalid&#39;: col.append(0.0)
            # print(e, n)
            # print(row[n])
            # pass
            col.append(row[n])  # la différence est içi entre readColCSV &amp;1 y a une couille mais .....
            # BGU : problem potentiel quand ligne vide
            # input(&#39;***&#39;)
    file.close()
    return col


def readColCSV(fichier, sep, n):
    &#34;&#34;&#34;Pour les deux premiers paramètres attention à bien utiliser les guillements
    car la fonction attend des chaines de caractères.
    fichier &lt;str&gt; : Le nom du fichier -&gt; &#34;mon_fichier.csv&#34;
    sep &lt;str&gt; : Le séparateur des colonnes par exemple -&gt; &#34;;&#34;
    n &lt;int&gt; : Le numéro de la colonne à lire

    retourne les valeurs de la colone du fichier en remplacant le separateur de
    decimal de , a . si besoin.
    Ignore les valeurs non int
    Echappe les valeurs vide de la colonne comme les fin de fichier de fin de fichier

    &gt;&gt;&gt; readColCSV (&#34;DebudFindeFichier.csv&#34;, &#34;;&#34;, 2)
    [0.0154, 0.0154, 0.0154, 0.0, 0.0154, 0.0]
    &#34;&#34;&#34;
    file = open(fichier, &#34;r&#34;)
    reader = csv.reader(file, delimiter=sep)
    col = []
    for row in reader:  # BGU suppress 1 des 2 de la double loop &#34;for row in reader&#34;, car elle pose des soucis de lecture sur l&#39;exemple: readColCSV (&#34;DebudFindeFichier.csv&#34;, &#34;;&#34;, 2)
        for row in reader:
            try:
                notation_point = row[n].replace(&#34;,&#34;, &#34;.&#34;)
                col.append(float(notation_point))
            except:
                if n &lt; len(row) and row[n] == &#39;Invalid&#39;: col.append(0.0)
                pass
    file.close()
    return col


# determination des coefficients en fonction du nombre de paliers pour la génération de paliers ascendents et descendants
def gen_nom_paliers(n):
    &#34;&#34;&#34;
    Parametres
    ----------
    n (int) : nombre de paliers

    return
    ------
    une liste incrémentée ascendant et descendant axée sur le milleu du nombe passé en argument
    &gt;&gt;&gt; print (gen_nom_paliers(9))
    (0, 1, 2, 3, 4, 3, 2, 1, 0)
    &#34;&#34;&#34;
    return tuple(range(int(n / 2 + 1))) + tuple(range(int(n / 2 - 1), -1, -1))


# Recuperation des valeurs pour detection separation des paliers avec
def paliers_mark():
    &#34;&#34;&#34;Definition de la valeur pour marquer la séparation des paliers.

    Valeur
    ------
    -0.03

    Returns
    -------
    La valeur
    &#34;&#34;&#34;
    return float(-0.03)


def sep_values(sv):
    &#34;&#34;&#34;
    Parameters
    ----------
    sv : TYPE,list
        DESCRIPTION.
        Liste de valeurs décimales, ayant la forme d&#39;un signal carré ascendant puis descendant
        (données expérimentales).
    &gt;&gt;&gt; a = [0.0015  ,0.0015 ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0206 , 0.0779 , 0.1577 , 0.1747 , 0.1769 , 0.1675 , 0.1447 , 0.1294 , 0.1219 , 0.1193 , 0.1187 , 0.1179 , 0.1174 , 0.1175 , 0.1172 , 0.1168 , 0.1169 , 0.1165 , 0.1166 , 0.1167 , 0.1168 , 0.1173 , 0.1176 , 0.1168 , 0.1176 , 0.1172 , 0.1173 , 0.1171 , 0.1165 , 0.1172 , 0.1173 , 0.1174 , 0.1172 , 0.1175 , 0.1177 , 0.1172 , 0.1173 , 0.1173 , 0.1176 , 0.1178 , 0.1173 , 0.1174 , 0.1174 , 0.1172 , 0.1173 , 0.1173 , 0.1174 , 0.1173 , 0.1169 , 0.1171 , 0.1174 , 0.1171 , 0.1172 , 0.1173 , 0.1164 , 0.1164 , 0.1165 , 0.1164 , 0.1165 , 0.1168 , 0.1171 , 0.1172 , 0.1171 , 0.1172 , 0.1177 , 0.1175 , 0.1174 , 0.1176 , 0.1173 , 0.1173 , 0.1171 , 0.1171 , 0.1168 , 0.1167 , 0.1169 , 0.1169 , 0.1169 , 0.1171 , 0.1172 , 0.1173 , 0.2008 , 0.2177 , 0.2205 , 0.2219 , 0.2236 , 0.2237 , 0.2216 , 0.2217 , 0.2216 , 0.2225 , 0.2242 , 0.2231 , 0.2226 , 0.2233 , 0.2225 , 0.2228 , 0.2239 , 0.2239 , 0.2245 , 0.2231 , 0.2228 , 0.2233 , 0.2237 , 0.2238 , 0.2232 , 0.2228 , 0.2236 , 0.3808 , 0.4189 , 0.4319 , 0.4338 , 0.4339 , 0.4307 , 0.4313 , 0.4342 , 0.4319 , 0.4332 , 0.4333 , 0.4329 , 0.4358 , 0.4366 , 0.4353 , 0.4343 , 0.4343 , 0.4337 , 0.4341 , 0.4363 , 0.4318 , 0.4319 , 0.4322 , 0.4312 , 0.4334 , 0.4333 , 0.4334 , 0.4322 , 0.4359 , 0.4337 , 0.4319 , 0.4313 , 0.4325 , 0.4317 , 0.4313 , 0.4307 , 0.4318 , 0.4283 , 0.5441 , 0.6355 , 0.6491 , 0.6531 , 0.6504 , 0.6537 , 0.6538 , 0.6546 , 0.6529 , 0.6537 , 0.6538 , 0.6539 , 0.6539 , 0.6538 , 0.6539 , 0.6539 , 0.6539 , 0.6539 , 0.6534 , 0.6538 , 0.6539 , 0.6534 , 0.6535 , 0.6534 , 0.6525 , 0.6528 , 0.6529 , 0.6554 , 0.6558 , 0.6559 , 0.5521 , 0.4593 , 0.4364 , 0.4325 , 0.4279 , 0.4299 , 0.4287 , 0.4307 , 0.4308 , 0.4309 , 0.4311 , 0.4321 , 0.4328 , 0.4282 , 0.4285 , 0.4324 , 0.4331 , 0.4317 , 0.4328 , 0.4328 , 0.4313 , 0.4332 , 0.4321 , 0.4321 , 0.4351 , 0.4287 , 0.4336 , 0.4304 , 0.4318 , 0.4275 , 0.4271 , 0.4239 , 0.4237 , 0.4054 , 0.2998 , 0.2448 , 0.2449 , 0.2193 , 0.2205 , 0.2189 , 0.2175 , 0.2191 , 0.2197 , 0.2202 , 0.2194 , 0.2189 , 0.2184 , 0.2174 , 0.2179 , 0.2180 , 0.2179 , 0.2195 , 0.2194 , 0.2187 , 0.2211 , 0.2206 , 0.2207 , 0.2212 , 0.2205 , 0.2207 , 0.2208 , 0.2206 , 0.2204 , 0.2195 , 0.2209 , 0.2210 , 0.2203 , 0.2204 , 0.2116 , 0.1881 , 0.18 , 0.1771 , 0.1754 , 0.1606 , 0.1391 , 0.1261 , 0.1209 , 0.1192 , 0.1181 , 0.1181 , 0.1182 , 0.1178 , 0.1175 , 0.1176 , 0.1167 , 0.1179 , 0.1180 , 0.1174 , 0.1174 , 0.1177 , 0.1178 , 0.1176 , 0.1178 , 0.1172 , 0.1178 , 0.1177 , 0.1184 , 0.1182 , 0.1183 , 0.1184 , 0.1181 , 0.1173 , 0.0015 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0015 , 0.0017 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0009 , 0.0010 , 0.0011 , 0.0011 , 0.0011 , 0.0012 , 0.0009 , 0.0005 , 0.0007 , 0.0007 , 0.0005 , 0.0005 , 0.0008 , 0.0008 , 0.0007 , 0.0004 , 0.0005 , 0.0004 , 0.0004 , 0.0004 , 0.0009 , 0.0008 , 0.0009 , ]

    Returns
    -------
    values_sep : TYPE, list
        DESCRIPTION.
        La liste de sortie est l&#39;identification des paliers par le remplacement de sa première
        valeur par paliers_mark(). Une première boucle nettoie le signal des valeurs aberrantes
        Dû à la mesure.
        La deuxième boucle identifie les paliers
    &gt;&gt;&gt; type(sep_values(a))
    &lt;class &#39;list&#39;&gt;

    &#34;&#34;&#34;
    seuil = 0.052  # seuil de détection des changements de paliers
    sensibilite = 0.014  # seuil de nettoyage
    nb_values = len(sv)
    values_sep = list()  # Donne brute avec identification des étages
    nb_remplacement = 1

    for i in range(nb_values - abs(nb_remplacement) - 5):
        if abs(sv[i + 5] - sv[
            i]) &lt; sensibilite:  # attention le i+x (5) est à mettre en accord avec les valeurs d&#39;exclusion des moyenne et ecartype du pdf et de l&#39;interface graphique
            sv[i] = sv[i]
        else:
            sv[i] = sv[i - nb_remplacement]

    for i in range(nb_values - 1):
        if abs(sv[i + 1] - sv[i]) &gt; seuil or abs(sv[i] - sv[i + 1]) &gt; seuil:
            values_sep.append(paliers_mark())
        else:
            values_sep.append(sv[i])
    return values_sep


def sep_values2(sv):
    &#34;&#34;&#34;
    Parameters
    ----------
    sv : TYPE,list
        DESCRIPTION.
        Liste de valeurs décimales, ayant la forme d&#39;un signal carré ascendant puis descendant
        (données expérimentales).
    &gt;&gt;&gt; a = [0.0015  ,0.0015 ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0206 , 0.0779 , 0.1577 , 0.1747 , 0.1769 , 0.1675 , 0.1447 , 0.1294 , 0.1219 , 0.1193 , 0.1187 , 0.1179 , 0.1174 , 0.1175 , 0.1172 , 0.1168 , 0.1169 , 0.1165 , 0.1166 , 0.1167 , 0.1168 , 0.1173 , 0.1176 , 0.1168 , 0.1176 , 0.1172 , 0.1173 , 0.1171 , 0.1165 , 0.1172 , 0.1173 , 0.1174 , 0.1172 , 0.1175 , 0.1177 , 0.1172 , 0.1173 , 0.1173 , 0.1176 , 0.1178 , 0.1173 , 0.1174 , 0.1174 , 0.1172 , 0.1173 , 0.1173 , 0.1174 , 0.1173 , 0.1169 , 0.1171 , 0.1174 , 0.1171 , 0.1172 , 0.1173 , 0.1164 , 0.1164 , 0.1165 , 0.1164 , 0.1165 , 0.1168 , 0.1171 , 0.1172 , 0.1171 , 0.1172 , 0.1177 , 0.1175 , 0.1174 , 0.1176 , 0.1173 , 0.1173 , 0.1171 , 0.1171 , 0.1168 , 0.1167 , 0.1169 , 0.1169 , 0.1169 , 0.1171 , 0.1172 , 0.1173 , 0.2008 , 0.2177 , 0.2205 , 0.2219 , 0.2236 , 0.2237 , 0.2216 , 0.2217 , 0.2216 , 0.2225 , 0.2242 , 0.2231 , 0.2226 , 0.2233 , 0.2225 , 0.2228 , 0.2239 , 0.2239 , 0.2245 , 0.2231 , 0.2228 , 0.2233 , 0.2237 , 0.2238 , 0.2232 , 0.2228 , 0.2236 , 0.3808 , 0.4189 , 0.4319 , 0.4338 , 0.4339 , 0.4307 , 0.4313 , 0.4342 , 0.4319 , 0.4332 , 0.4333 , 0.4329 , 0.4358 , 0.4366 , 0.4353 , 0.4343 , 0.4343 , 0.4337 , 0.4341 , 0.4363 , 0.4318 , 0.4319 , 0.4322 , 0.4312 , 0.4334 , 0.4333 , 0.4334 , 0.4322 , 0.4359 , 0.4337 , 0.4319 , 0.4313 , 0.4325 , 0.4317 , 0.4313 , 0.4307 , 0.4318 , 0.4283 , 0.5441 , 0.6355 , 0.6491 , 0.6531 , 0.6504 , 0.6537 , 0.6538 , 0.6546 , 0.6529 , 0.6537 , 0.6538 , 0.6539 , 0.6539 , 0.6538 , 0.6539 , 0.6539 , 0.6539 , 0.6539 , 0.6534 , 0.6538 , 0.6539 , 0.6534 , 0.6535 , 0.6534 , 0.6525 , 0.6528 , 0.6529 , 0.6554 , 0.6558 , 0.6559 , 0.5521 , 0.4593 , 0.4364 , 0.4325 , 0.4279 , 0.4299 , 0.4287 , 0.4307 , 0.4308 , 0.4309 , 0.4311 , 0.4321 , 0.4328 , 0.4282 , 0.4285 , 0.4324 , 0.4331 , 0.4317 , 0.4328 , 0.4328 , 0.4313 , 0.4332 , 0.4321 , 0.4321 , 0.4351 , 0.4287 , 0.4336 , 0.4304 , 0.4318 , 0.4275 , 0.4271 , 0.4239 , 0.4237 , 0.4054 , 0.2998 , 0.2448 , 0.2449 , 0.2193 , 0.2205 , 0.2189 , 0.2175 , 0.2191 , 0.2197 , 0.2202 , 0.2194 , 0.2189 , 0.2184 , 0.2174 , 0.2179 , 0.2180 , 0.2179 , 0.2195 , 0.2194 , 0.2187 , 0.2211 , 0.2206 , 0.2207 , 0.2212 , 0.2205 , 0.2207 , 0.2208 , 0.2206 , 0.2204 , 0.2195 , 0.2209 , 0.2210 , 0.2203 , 0.2204 , 0.2116 , 0.1881 , 0.18 , 0.1771 , 0.1754 , 0.1606 , 0.1391 , 0.1261 , 0.1209 , 0.1192 , 0.1181 , 0.1181 , 0.1182 , 0.1178 , 0.1175 , 0.1176 , 0.1167 , 0.1179 , 0.1180 , 0.1174 , 0.1174 , 0.1177 , 0.1178 , 0.1176 , 0.1178 , 0.1172 , 0.1178 , 0.1177 , 0.1184 , 0.1182 , 0.1183 , 0.1184 , 0.1181 , 0.1173 , 0.0015 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0015 , 0.0017 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0009 , 0.0010 , 0.0011 , 0.0011 , 0.0011 , 0.0012 , 0.0009 , 0.0005 , 0.0007 , 0.0007 , 0.0005 , 0.0005 , 0.0008 , 0.0008 , 0.0007 , 0.0004 , 0.0005 , 0.0004 , 0.0004 , 0.0004 , 0.0009 , 0.0008 , 0.0009 , ]

    Returns
    -------
    values_sep : TYPE, list
        DESCRIPTION. Pour le traitement d&#39;un type de capteur (Mac Soufflerie)
        La liste de sortie est l&#39;identification des paliers par le remplacement de sa première
        valeur par paliers_mark(). Une première boucle nettoie le signal des valeurs aberrantes
        Dû à la mesure.
        La deuxième boucle identifie les paliers
    &gt;&gt;&gt; type(sep_values(a))
    &lt;class &#39;list&#39;&gt;

    &#34;&#34;&#34;
    seuil = 0.5  # seuil de détection des changements de paliers
    sensibilite = 0.21  # seuil de nettoyage
    nb_values = len(sv)
    values_sep = list()  # Donne brute avec identification des étages
    nb_remplacement = 1

    for i in range(nb_values - abs(nb_remplacement) - 5):
        if abs(sv[i + 5] - sv[
            i]) &lt; sensibilite:  # attention le i+x (5) est à mettre en accord avec les valeurs d&#39;exclusion des moyenne et ecartype du pdf et de l&#39;interface graphique
            sv[i] = sv[i]
        else:
            sv[i] = sv[i - nb_remplacement]

    for i in range(nb_values - 1):
        if abs(sv[i + 1] - sv[i]) &gt; seuil or abs(sv[i] - sv[i + 1]) &gt; seuil:
            values_sep.append(paliers_mark())
        else:
            values_sep.append(sv[i])
    return values_sep


# Recuperation des valeurs generer avec separation par etages
def info_values(iv):
    &#34;&#34;&#34; Recuperation des valeurs generer avec separation par paliers.
    prend les valeurs d&#39;un capteur pour les ordonnées par paliers avec identification des informations
    par palier comme le nombre de paliers la longueur de chaque palier.

    return:
    -------
    une liste imbriqué de chaque info

    &#34;&#34;&#34;
    nb_values = len(iv)
    values_sep = list([0] * nb_values)  # Donne brute avec identification des étages
    paliers_find = 1
    plage_len_find = list()
    count = 1
    for i in range(nb_values):
        if iv[i] == paliers_mark():
            values_sep[i] = paliers_mark()
            paliers_find = paliers_find + 1
            plage_len_find.append(count)
            count = 1
        else:
            values_sep[i] = iv[i]
            if i == (nb_values - 1):
                plage_len_find.append(count)
            count = count + 1
    return [paliers_find, plage_len_find, nb_values, values_sep]


# creation de la liste du nombre de paliers avec la taille
def make_paliers(paliers_find, plage_len_find):
    &#34;&#34;&#34;Création d&#39;une liste avec chaque palier, le passage est obscure sur le pourquoi :)
    je refais une liste imbriqué avec le nombre de paliers associer à ses valeurs de paliers
    utile pour les graph il me semble, car les deux biblio de graph prennent pas les mêmes structures je crois
    ...
    TBC
    &#34;&#34;&#34;
    paliers = list([0] * paliers_find)
    for i in range(len(paliers)):
        paliers[i] = list([0] * plage_len_find[i])
    return paliers


# Passage de données separer, en liste des tableaux remplis
def paliers_values_sep(values_sep, nb_values, paliers):
    &#34;&#34;&#34;Passage de données separer, en liste des tableaux remplis,
    je sais plus pourquoi :)
    TBC
    &#34;&#34;&#34;
    count = 0
    nb = 0
    values_paliers = paliers
    for i in range(nb_values):
        if values_sep[i] == paliers_mark():
            values_paliers[count][nb] = values_sep[i - 1]
            count = count + 1
            nb = 0
        else:
            values_paliers[count][nb] = values_sep[i]
            nb = nb + 1
    return values_paliers


# Retour une liste des données des capteurs en sous list de données par capteurs
def isol_capteurs(values):
    &#34;&#34;&#34;Içi c&#39;est la premiere séparation du signal par capteur, le test est si on trouve un nom de capteur
    tous ce qui suit jusqu&#39;a l&#39;autre nom ou la fin sont les données du capteur :p
    TBC
    &#34;&#34;&#34;
    del values[0:23]
    last_key = None
    values_capteurs = dict()
    for value in values:
        if value == &#39;Invalid&#39;:  # remarque BGU 2022-08_09: impossible, ça a été filtré en amont par readColCSV &amp;1
            #Surement un traitement antérieure au readCol :)
            value = 0.01
        if isinstance(value, str):
            values_capteurs[value] = list()
            last_key = value
        elif last_key:
            values_capteurs[last_key].append(value)
        else:
            raise KeyError(&#34;error in the first item&#34;)
    return (values_capteurs)  # retourne un dic des noms de capteur avec les valeurs


def traitement_general_donnees(paliers_find, paliers_find2, values_sep_paliers, values_sep_paliers2, entete):
    &#34;&#34;&#34;Calcule les moyennes et écart-types pour remplir les tabs -
    Sert à la fois à l&#39;affichage dans le GUI et à la génération de pdf
    Merci Bruno
    &#34;&#34;&#34;

    moyenne = list([&#34;&#34;] * paliers_find)
    moyenne2 = list([&#34;&#34;] * paliers_find2)
    ecartype = list([&#34;&#34;] * paliers_find)
    ecartype2 = list([&#34;&#34;] * paliers_find2)
    donneestraitees2 = [[&#34;0&#34;] * len(entete)] * paliers_find
    #
    if len(range(paliers_find)) == len(range(paliers_find2)):
        #
        for i, j in zip(range(paliers_find), range(paliers_find2)):
            #
            moyenne[i] = mean(values_sep_paliers[i][
                              7: -7])  # Correction, suppression des valeurs de début et de fin pour les traitements.
            ecartype[i] = pstdev(values_sep_paliers[i][7: -7]) * 1000
            #
            if values_sep_paliers2[j][7: -7]:
                # moyenne2[j] = mean(values_sep_paliers2[i][7: -7])  #BGU: ancienne formulation bizarre
                # ecartype2[j] = pstdev(values_sep_paliers2[i][7: -7])  #BGU: ancienne formulation bizarre
                moyenne2[j] = mean(values_sep_paliers2[j][7: -7])
                ecartype2[j] = pstdev(values_sep_paliers2[j][7: -7])
            else:
                moyenne2[j] = 0
                ecartype2[j] = 0
            donneestraitees2[i] = (str(round(moyenne[i], 4)), str(round(ecartype[i], 4)), str(round(moyenne2[j], 4)),
                                   str(round(ecartype2[j], 4)))
            # donneestraitees2[i] = (str(round(moyenne[j],4)),str(round(ecartype2[i],4)), str(round(moyenne2[i],4)),str(round(ecartype[j],4))) #BGU: ancienne formulation bizarre
            # Attention il y a une inversion, une mauvais attribuation des valeurs ecartype 2 correspond au premier capteur ?
            #
    else:
        for i in range(paliers_find):
            moyenne[i] = mean(values_sep_paliers[i][
                              7: -7])  # Correction, supression des valeurs de début et de fin pour les traitements.
            ecartype[i] = pstdev(values_sep_paliers[i][7: -7]) * 1000
            donneestraitees2[i] = (&#39;Oups&#39;, str(round(moyenne[i], 4)), str(round(ecartype[i], 4)), &#34;Oups&#34;)
    return donneestraitees2


if __name__ == &#34;__main__&#34;:
    testmod()</code></pre>
            </details>
        </section>
        <section>
        </section>
        <section>
        </section>
        <section>
            <h2 class="section-title" id="header-functions">Functions</h2>
            <dl>
                <dt id="Sensorem_Beta-C.FonctionsSignal.gen_nom_paliers"><code class="name flex">
                    <span>def <span class="ident">gen_nom_paliers</span></span>(<span>n)</span>
                </code></dt>
                <dd>
                    <div class="desc"><h2 id="parametres">Parametres</h2>
                        <p>n (int) : nombre de paliers</p>
                        <h2 id="return">Return</h2>
                        <p>une liste incrémentée ascendant et descendant axée sur le milleu du nombe passé en
                            argument</p>
                        <pre><code class="language-python-repl">&gt;&gt;&gt; print (gen_nom_paliers(9))
(0, 1, 2, 3, 4, 3, 2, 1, 0)
</code></pre>
                    </div>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">def gen_nom_paliers(n):
    &#34;&#34;&#34;
    Parametres
    ----------
    n (int) : nombre de paliers

    return
    ------
    une liste incrémentée ascendant et descendant axée sur le milleu du nombe passé en argument
    &gt;&gt;&gt; print (gen_nom_paliers(9))
    (0, 1, 2, 3, 4, 3, 2, 1, 0)
    &#34;&#34;&#34;
    return tuple(range(int(n / 2 + 1))) + tuple(range(int(n / 2 - 1), -1, -1))</code></pre>
                    </details>
                </dd>
                <dt id="Sensorem_Beta-C.FonctionsSignal.info_values"><code class="name flex">
                    <span>def <span class="ident">info_values</span></span>(<span>iv)</span>
                </code></dt>
                <dd>
                    <div class="desc"><p>Recuperation des valeurs generer avec separation par paliers.
                        prend les valeurs d'un capteur pour les ordonnées par paliers avec identification des
                        informations
                        par palier comme le nombre de paliers la longueur de chaque palier.</p>
                        <h2 id="return">return:</h2>
                        <p>une liste imbriqué de chaque info</p></div>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">def info_values(iv):
    &#34;&#34;&#34; Recuperation des valeurs generer avec separation par paliers.
    prend les valeurs d&#39;un capteur pour les ordonnées par paliers avec identification des informations
    par palier comme le nombre de paliers la longueur de chaque palier.

    return:
    -------
    une liste imbriqué de chaque info

    &#34;&#34;&#34;
    nb_values = len(iv)
    values_sep = list([0] * nb_values)  # Donne brute avec identification des étages
    paliers_find = 1
    plage_len_find = list()
    count = 1
    for i in range(nb_values):
        if iv[i] == paliers_mark():
            values_sep[i] = paliers_mark()
            paliers_find = paliers_find + 1
            plage_len_find.append(count)
            count = 1
        else:
            values_sep[i] = iv[i]
            if i == (nb_values - 1):
                plage_len_find.append(count)
            count = count + 1
    return [paliers_find, plage_len_find, nb_values, values_sep]</code></pre>
                    </details>
                </dd>
                <dt id="Sensorem_Beta-C.FonctionsSignal.isol_capteurs"><code class="name flex">
                    <span>def <span class="ident">isol_capteurs</span></span>(<span>values)</span>
                </code></dt>
                <dd>
                    <div class="desc"><p>Içi c'est la premiere séparation du signal par capteur, le test est si on
                        trouve un nom de capteur
                        tous ce qui suit jusqu'a l'autre nom ou la fin sont les données du capteur :p
                        TBC</p></div>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">def isol_capteurs(values):
    &#34;&#34;&#34;Içi c&#39;est la premiere séparation du signal par capteur, le test est si on trouve un nom de capteur
    tous ce qui suit jusqu&#39;a l&#39;autre nom ou la fin sont les données du capteur :p
    TBC
    &#34;&#34;&#34;
    del values[0:23]
    last_key = None
    values_capteurs = dict()
    for value in values:
        if value == &#39;Invalid&#39;:  # remarque BGU 2022-08_09: impossible, ça a été filtré en amont par readColCSV &amp;1
            #Surement un traitement antérieure au readCol :)
            value = 0.01
        if isinstance(value, str):
            values_capteurs[value] = list()
            last_key = value
        elif last_key:
            values_capteurs[last_key].append(value)
        else:
            raise KeyError(&#34;error in the first item&#34;)
    return (values_capteurs)  # retourne un dic des noms de capteur avec les valeurs</code></pre>
                    </details>
                </dd>
                <dt id="Sensorem_Beta-C.FonctionsSignal.make_paliers"><code class="name flex">
                    <span>def <span class="ident">make_paliers</span></span>(<span>paliers_find, plage_len_find)</span>
                </code></dt>
                <dd>
                    <div class="desc"><p>Création d'une liste avec chaque palier, le passage est obscure sur le pourquoi
                        :)
                        je refais une liste imbriqué avec le nombre de paliers associer à ses valeurs de paliers
                        utile pour les graph il me semble, car les deux biblio de graph prennent pas les mêmes
                        structures je crois
                        &hellip;
                        TBC</p></div>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">def make_paliers(paliers_find, plage_len_find):
    &#34;&#34;&#34;Création d&#39;une liste avec chaque palier, le passage est obscure sur le pourquoi :)
    je refais une liste imbriqué avec le nombre de paliers associer à ses valeurs de paliers
    utile pour les graph il me semble, car les deux biblio de graph prennent pas les mêmes structures je crois
    ...
    TBC
    &#34;&#34;&#34;
    paliers = list([0] * paliers_find)
    for i in range(len(paliers)):
        paliers[i] = list([0] * plage_len_find[i])
    return paliers</code></pre>
                    </details>
                </dd>
                <dt id="Sensorem_Beta-C.FonctionsSignal.paliers_mark"><code class="name flex">
                    <span>def <span class="ident">paliers_mark</span></span>(<span>)</span>
                </code></dt>
                <dd>
                    <div class="desc"><p>Definition de la valeur pour marquer la séparation des paliers.</p>
                        <h2 id="valeur">Valeur</h2>
                        <p>-0.03</p>
                        <h2 id="returns">Returns</h2>
                        <dl>
                            <dt><code>La valeur</code></dt>
                            <dd>&nbsp;</dd>
                        </dl>
                    </div>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">def paliers_mark():
    &#34;&#34;&#34;Definition de la valeur pour marquer la séparation des paliers.

    Valeur
    ------
    -0.03

    Returns
    -------
    La valeur
    &#34;&#34;&#34;
    return float(-0.03)</code></pre>
                    </details>
                </dd>
                <dt id="Sensorem_Beta-C.FonctionsSignal.paliers_values_sep"><code class="name flex">
                    <span>def <span
                            class="ident">paliers_values_sep</span></span>(<span>values_sep, nb_values, paliers)</span>
                </code></dt>
                <dd>
                    <div class="desc"><p>Passage de données separer, en liste des tableaux remplis,
                        je sais plus pourquoi :)
                        TBC</p></div>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">def paliers_values_sep(values_sep, nb_values, paliers):
    &#34;&#34;&#34;Passage de données separer, en liste des tableaux remplis,
    je sais plus pourquoi :)
    TBC
    &#34;&#34;&#34;
    count = 0
    nb = 0
    values_paliers = paliers
    for i in range(nb_values):
        if values_sep[i] == paliers_mark():
            values_paliers[count][nb] = values_sep[i - 1]
            count = count + 1
            nb = 0
        else:
            values_paliers[count][nb] = values_sep[i]
            nb = nb + 1
    return values_paliers</code></pre>
                    </details>
                </dd>
                <dt id="Sensorem_Beta-C.FonctionsSignal.prep_donnees_graph"><code class="name flex">
                    <span>def <span class="ident">prep_donnees_graph</span></span>(<span>donnees)</span>
                </code></dt>
                <dd>
                    <div class="desc"><p>retourne une liste d'éléments en listes d'éléments incrémentée,</p>
                        <pre><code class="language-python-repl">&gt;&gt;&gt; prep_donnees_graph([1,2,3,4,5])
[[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]]
</code></pre>
                    </div>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">def prep_donnees_graph(donnees):
    &#34;&#34;&#34;
    retourne une liste d&#39;éléments en listes d&#39;éléments incrémentée,
    &gt;&gt;&gt; prep_donnees_graph([1,2,3,4,5])
    [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]]
    &#34;&#34;&#34;
    return [[i, donnee] for i, donnee in enumerate(donnees)]</code></pre>
                    </details>
                </dd>
                <dt id="Sensorem_Beta-C.FonctionsSignal.readColCSV"><code class="name flex">
                    <span>def <span class="ident">readColCSV</span></span>(<span>fichier, sep, n)</span>
                </code></dt>
                <dd>
                    <div class="desc">
                        <p>Pour les deux premiers paramètres attention à bien utiliser les guillements
                            car la fonction attend des chaines de caractères.
                            fichier
                            <str> : Le nom du fichier -&gt; "mon_fichier.csv"
                                sep
                                <str> : Le séparateur des colonnes par exemple -&gt; ";"
                                    n
                                    <int> : Le numéro de la colonne à lire
                        </p>
                        <p>retourne les valeurs de la colone du fichier en remplacant le separateur de
                            decimal de , a . si besoin.
                            Ignore les valeurs non int
                            Echappe les valeurs vide de la colonne comme les fin de fichier de fin de fichier</p>
                        <pre><code class="language-python-repl">&gt;&gt;&gt; readColCSV (&quot;DebudFindeFichier.csv&quot;, &quot;;&quot;, 2)
[0.0154, 0.0154, 0.0154, 0.0, 0.0154, 0.0]
</code></pre>
                    </div>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">def readColCSV(fichier, sep, n):
    &#34;&#34;&#34;Pour les deux premiers paramètres attention à bien utiliser les guillements
    car la fonction attend des chaines de caractères.
    fichier &lt;str&gt; : Le nom du fichier -&gt; &#34;mon_fichier.csv&#34;
    sep &lt;str&gt; : Le séparateur des colonnes par exemple -&gt; &#34;;&#34;
    n &lt;int&gt; : Le numéro de la colonne à lire

    retourne les valeurs de la colone du fichier en remplacant le separateur de
    decimal de , a . si besoin.
    Ignore les valeurs non int
    Echappe les valeurs vide de la colonne comme les fin de fichier de fin de fichier

    &gt;&gt;&gt; readColCSV (&#34;DebudFindeFichier.csv&#34;, &#34;;&#34;, 2)
    [0.0154, 0.0154, 0.0154, 0.0, 0.0154, 0.0]
    &#34;&#34;&#34;
    file = open(fichier, &#34;r&#34;)
    reader = csv.reader(file, delimiter=sep)
    col = []
    for row in reader:  # BGU suppress 1 des 2 de la double loop &#34;for row in reader&#34;, car elle pose des soucis de lecture sur l&#39;exemple: readColCSV (&#34;DebudFindeFichier.csv&#34;, &#34;;&#34;, 2)
        for row in reader:
            try:
                notation_point = row[n].replace(&#34;,&#34;, &#34;.&#34;)
                col.append(float(notation_point))
            except:
                if n &lt; len(row) and row[n] == &#39;Invalid&#39;: col.append(0.0)
                pass
    file.close()
    return col</code></pre>
                    </details>
                </dd>
                <dt id="Sensorem_Beta-C.FonctionsSignal.readColCSV1"><code class="name flex">
                    <span>def <span class="ident">readColCSV1</span></span>(<span>fichier, sep, n)</span>
                </code></dt>
                <dd>
                    <div class="desc">
                        <p>Lecture complete du fichier
                            Pour les deux premiers paramètres attention à bien utiliser les guillements
                            car la fonction attend des chaines de caractères.
                            fichier
                            <str> : Le nom du fichier -&gt; "mon_fichier.csv"
                                sep
                                <str> : Le séparateur des colonnes par exemple -&gt; ";"
                                    n
                                    <int> : Le numéro de la colonne à lire
                        </p>
                    </div>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">def readColCSV1(fichier, sep, n):
    &#34;&#34;&#34;
    Lecture complete du fichier
    Pour les deux premiers paramètres attention à bien utiliser les guillements
    car la fonction attend des chaines de caractères.
    fichier &lt;str&gt; : Le nom du fichier -&gt; &#34;mon_fichier.csv&#34;
    sep &lt;str&gt; : Le séparateur des colonnes par exemple -&gt; &#34;;&#34;
    n &lt;int&gt; : Le numéro de la colonne à lire
    &#34;&#34;&#34;
    file = open(fichier, &#34;r&#34;)
    reader = csv.reader(file, delimiter=sep)
    col = []
    for row in reader:
        # if row[n] == &#34;Invalid&#34;: row[n]=float(0.0)
        if n &lt; len(row) and row[n] == &#39;Invalid&#39;:
            row[n] = float(0.0)
            # BGU supress ? car row[n] peut planter (or try/except), notamment sur une ligne vide
        try:
            notation_point = row[n].replace(&#34;,&#34;, &#34;.&#34;)
            col.append(float(notation_point))
        # except Exception as e:
        except :
            if n &lt; len(row) and row[n] == &#39;Invalid&#39;: col.append(0.0)
            # print(e, n)
            # print(row[n])
            # pass
            col.append(row[n])  # la différence est içi entre readColCSV &amp;1 y a une couille mais .....
            # BGU : problem potentiel quand ligne vide
            # input(&#39;***&#39;)
    file.close()
    return col</code></pre>
                    </details>
                </dd>
                <dt id="Sensorem_Beta-C.FonctionsSignal.sep_values"><code class="name flex">
                    <span>def <span class="ident">sep_values</span></span>(<span>sv)</span>
                </code></dt>
                <dd>
                    <div class="desc"><h2 id="parameters">Parameters</h2>
                        <dl>
                            <dt><strong><code>sv</code></strong> :&ensp;<code>TYPE,list</code></dt>
                            <dd>DESCRIPTION.
                                Liste de valeurs décimales, ayant la forme d'un signal carré ascendant puis descendant
                                (données expérimentales).
                            </dd>
                        </dl>
                        <pre><code class="language-python-repl">&gt;&gt;&gt; a = [0.0015  ,0.0015 ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0206 , 0.0779 , 0.1577 , 0.1747 , 0.1769 , 0.1675 , 0.1447 , 0.1294 , 0.1219 , 0.1193 , 0.1187 , 0.1179 , 0.1174 , 0.1175 , 0.1172 , 0.1168 , 0.1169 , 0.1165 , 0.1166 , 0.1167 , 0.1168 , 0.1173 , 0.1176 , 0.1168 , 0.1176 , 0.1172 , 0.1173 , 0.1171 , 0.1165 , 0.1172 , 0.1173 , 0.1174 , 0.1172 , 0.1175 , 0.1177 , 0.1172 , 0.1173 , 0.1173 , 0.1176 , 0.1178 , 0.1173 , 0.1174 , 0.1174 , 0.1172 , 0.1173 , 0.1173 , 0.1174 , 0.1173 , 0.1169 , 0.1171 , 0.1174 , 0.1171 , 0.1172 , 0.1173 , 0.1164 , 0.1164 , 0.1165 , 0.1164 , 0.1165 , 0.1168 , 0.1171 , 0.1172 , 0.1171 , 0.1172 , 0.1177 , 0.1175 , 0.1174 , 0.1176 , 0.1173 , 0.1173 , 0.1171 , 0.1171 , 0.1168 , 0.1167 , 0.1169 , 0.1169 , 0.1169 , 0.1171 , 0.1172 , 0.1173 , 0.2008 , 0.2177 , 0.2205 , 0.2219 , 0.2236 , 0.2237 , 0.2216 , 0.2217 , 0.2216 , 0.2225 , 0.2242 , 0.2231 , 0.2226 , 0.2233 , 0.2225 , 0.2228 , 0.2239 , 0.2239 , 0.2245 , 0.2231 , 0.2228 , 0.2233 , 0.2237 , 0.2238 , 0.2232 , 0.2228 , 0.2236 , 0.3808 , 0.4189 , 0.4319 , 0.4338 , 0.4339 , 0.4307 , 0.4313 , 0.4342 , 0.4319 , 0.4332 , 0.4333 , 0.4329 , 0.4358 , 0.4366 , 0.4353 , 0.4343 , 0.4343 , 0.4337 , 0.4341 , 0.4363 , 0.4318 , 0.4319 , 0.4322 , 0.4312 , 0.4334 , 0.4333 , 0.4334 , 0.4322 , 0.4359 , 0.4337 , 0.4319 , 0.4313 , 0.4325 , 0.4317 , 0.4313 , 0.4307 , 0.4318 , 0.4283 , 0.5441 , 0.6355 , 0.6491 , 0.6531 , 0.6504 , 0.6537 , 0.6538 , 0.6546 , 0.6529 , 0.6537 , 0.6538 , 0.6539 , 0.6539 , 0.6538 , 0.6539 , 0.6539 , 0.6539 , 0.6539 , 0.6534 , 0.6538 , 0.6539 , 0.6534 , 0.6535 , 0.6534 , 0.6525 , 0.6528 , 0.6529 , 0.6554 , 0.6558 , 0.6559 , 0.5521 , 0.4593 , 0.4364 , 0.4325 , 0.4279 , 0.4299 , 0.4287 , 0.4307 , 0.4308 , 0.4309 , 0.4311 , 0.4321 , 0.4328 , 0.4282 , 0.4285 , 0.4324 , 0.4331 , 0.4317 , 0.4328 , 0.4328 , 0.4313 , 0.4332 , 0.4321 , 0.4321 , 0.4351 , 0.4287 , 0.4336 , 0.4304 , 0.4318 , 0.4275 , 0.4271 , 0.4239 , 0.4237 , 0.4054 , 0.2998 , 0.2448 , 0.2449 , 0.2193 , 0.2205 , 0.2189 , 0.2175 , 0.2191 , 0.2197 , 0.2202 , 0.2194 , 0.2189 , 0.2184 , 0.2174 , 0.2179 , 0.2180 , 0.2179 , 0.2195 , 0.2194 , 0.2187 , 0.2211 , 0.2206 , 0.2207 , 0.2212 , 0.2205 , 0.2207 , 0.2208 , 0.2206 , 0.2204 , 0.2195 , 0.2209 , 0.2210 , 0.2203 , 0.2204 , 0.2116 , 0.1881 , 0.18 , 0.1771 , 0.1754 , 0.1606 , 0.1391 , 0.1261 , 0.1209 , 0.1192 , 0.1181 , 0.1181 , 0.1182 , 0.1178 , 0.1175 , 0.1176 , 0.1167 , 0.1179 , 0.1180 , 0.1174 , 0.1174 , 0.1177 , 0.1178 , 0.1176 , 0.1178 , 0.1172 , 0.1178 , 0.1177 , 0.1184 , 0.1182 , 0.1183 , 0.1184 , 0.1181 , 0.1173 , 0.0015 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0015 , 0.0017 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0009 , 0.0010 , 0.0011 , 0.0011 , 0.0011 , 0.0012 , 0.0009 , 0.0005 , 0.0007 , 0.0007 , 0.0005 , 0.0005 , 0.0008 , 0.0008 , 0.0007 , 0.0004 , 0.0005 , 0.0004 , 0.0004 , 0.0004 , 0.0009 , 0.0008 , 0.0009 , ]
</code></pre>
                        <h2 id="returns">Returns</h2>
                        <dl>
                            <dt><strong><code>values_sep</code></strong> :&ensp;<code>TYPE, list</code></dt>
                            <dd>DESCRIPTION.
                                La liste de sortie est l'identification des paliers par le remplacement de sa première
                                valeur par paliers_mark(). Une première boucle nettoie le signal des valeurs aberrantes
                                Dû à la mesure.
                                La deuxième boucle identifie les paliers
                            </dd>
                        </dl>
                        <pre><code class="language-python-repl">&gt;&gt;&gt; type(sep_values(a))
&lt;class 'list'&gt;
</code></pre>
                    </div>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">def sep_values(sv):
    &#34;&#34;&#34;
    Parameters
    ----------
    sv : TYPE,list
        DESCRIPTION.
        Liste de valeurs décimales, ayant la forme d&#39;un signal carré ascendant puis descendant
        (données expérimentales).
    &gt;&gt;&gt; a = [0.0015  ,0.0015 ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0206 , 0.0779 , 0.1577 , 0.1747 , 0.1769 , 0.1675 , 0.1447 , 0.1294 , 0.1219 , 0.1193 , 0.1187 , 0.1179 , 0.1174 , 0.1175 , 0.1172 , 0.1168 , 0.1169 , 0.1165 , 0.1166 , 0.1167 , 0.1168 , 0.1173 , 0.1176 , 0.1168 , 0.1176 , 0.1172 , 0.1173 , 0.1171 , 0.1165 , 0.1172 , 0.1173 , 0.1174 , 0.1172 , 0.1175 , 0.1177 , 0.1172 , 0.1173 , 0.1173 , 0.1176 , 0.1178 , 0.1173 , 0.1174 , 0.1174 , 0.1172 , 0.1173 , 0.1173 , 0.1174 , 0.1173 , 0.1169 , 0.1171 , 0.1174 , 0.1171 , 0.1172 , 0.1173 , 0.1164 , 0.1164 , 0.1165 , 0.1164 , 0.1165 , 0.1168 , 0.1171 , 0.1172 , 0.1171 , 0.1172 , 0.1177 , 0.1175 , 0.1174 , 0.1176 , 0.1173 , 0.1173 , 0.1171 , 0.1171 , 0.1168 , 0.1167 , 0.1169 , 0.1169 , 0.1169 , 0.1171 , 0.1172 , 0.1173 , 0.2008 , 0.2177 , 0.2205 , 0.2219 , 0.2236 , 0.2237 , 0.2216 , 0.2217 , 0.2216 , 0.2225 , 0.2242 , 0.2231 , 0.2226 , 0.2233 , 0.2225 , 0.2228 , 0.2239 , 0.2239 , 0.2245 , 0.2231 , 0.2228 , 0.2233 , 0.2237 , 0.2238 , 0.2232 , 0.2228 , 0.2236 , 0.3808 , 0.4189 , 0.4319 , 0.4338 , 0.4339 , 0.4307 , 0.4313 , 0.4342 , 0.4319 , 0.4332 , 0.4333 , 0.4329 , 0.4358 , 0.4366 , 0.4353 , 0.4343 , 0.4343 , 0.4337 , 0.4341 , 0.4363 , 0.4318 , 0.4319 , 0.4322 , 0.4312 , 0.4334 , 0.4333 , 0.4334 , 0.4322 , 0.4359 , 0.4337 , 0.4319 , 0.4313 , 0.4325 , 0.4317 , 0.4313 , 0.4307 , 0.4318 , 0.4283 , 0.5441 , 0.6355 , 0.6491 , 0.6531 , 0.6504 , 0.6537 , 0.6538 , 0.6546 , 0.6529 , 0.6537 , 0.6538 , 0.6539 , 0.6539 , 0.6538 , 0.6539 , 0.6539 , 0.6539 , 0.6539 , 0.6534 , 0.6538 , 0.6539 , 0.6534 , 0.6535 , 0.6534 , 0.6525 , 0.6528 , 0.6529 , 0.6554 , 0.6558 , 0.6559 , 0.5521 , 0.4593 , 0.4364 , 0.4325 , 0.4279 , 0.4299 , 0.4287 , 0.4307 , 0.4308 , 0.4309 , 0.4311 , 0.4321 , 0.4328 , 0.4282 , 0.4285 , 0.4324 , 0.4331 , 0.4317 , 0.4328 , 0.4328 , 0.4313 , 0.4332 , 0.4321 , 0.4321 , 0.4351 , 0.4287 , 0.4336 , 0.4304 , 0.4318 , 0.4275 , 0.4271 , 0.4239 , 0.4237 , 0.4054 , 0.2998 , 0.2448 , 0.2449 , 0.2193 , 0.2205 , 0.2189 , 0.2175 , 0.2191 , 0.2197 , 0.2202 , 0.2194 , 0.2189 , 0.2184 , 0.2174 , 0.2179 , 0.2180 , 0.2179 , 0.2195 , 0.2194 , 0.2187 , 0.2211 , 0.2206 , 0.2207 , 0.2212 , 0.2205 , 0.2207 , 0.2208 , 0.2206 , 0.2204 , 0.2195 , 0.2209 , 0.2210 , 0.2203 , 0.2204 , 0.2116 , 0.1881 , 0.18 , 0.1771 , 0.1754 , 0.1606 , 0.1391 , 0.1261 , 0.1209 , 0.1192 , 0.1181 , 0.1181 , 0.1182 , 0.1178 , 0.1175 , 0.1176 , 0.1167 , 0.1179 , 0.1180 , 0.1174 , 0.1174 , 0.1177 , 0.1178 , 0.1176 , 0.1178 , 0.1172 , 0.1178 , 0.1177 , 0.1184 , 0.1182 , 0.1183 , 0.1184 , 0.1181 , 0.1173 , 0.0015 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0015 , 0.0017 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0009 , 0.0010 , 0.0011 , 0.0011 , 0.0011 , 0.0012 , 0.0009 , 0.0005 , 0.0007 , 0.0007 , 0.0005 , 0.0005 , 0.0008 , 0.0008 , 0.0007 , 0.0004 , 0.0005 , 0.0004 , 0.0004 , 0.0004 , 0.0009 , 0.0008 , 0.0009 , ]

    Returns
    -------
    values_sep : TYPE, list
        DESCRIPTION.
        La liste de sortie est l&#39;identification des paliers par le remplacement de sa première
        valeur par paliers_mark(). Une première boucle nettoie le signal des valeurs aberrantes
        Dû à la mesure.
        La deuxième boucle identifie les paliers
    &gt;&gt;&gt; type(sep_values(a))
    &lt;class &#39;list&#39;&gt;

    &#34;&#34;&#34;
    seuil = 0.052  # seuil de détection des changements de paliers
    sensibilite = 0.014  # seuil de nettoyage
    nb_values = len(sv)
    values_sep = list()  # Donne brute avec identification des étages
    nb_remplacement = 1

    for i in range(nb_values - abs(nb_remplacement) - 5):
        if abs(sv[i + 5] - sv[
            i]) &lt; sensibilite:  # attention le i+x (5) est à mettre en accord avec les valeurs d&#39;exclusion des moyenne et ecartype du pdf et de l&#39;interface graphique
            sv[i] = sv[i]
        else:
            sv[i] = sv[i - nb_remplacement]

    for i in range(nb_values - 1):
        if abs(sv[i + 1] - sv[i]) &gt; seuil or abs(sv[i] - sv[i + 1]) &gt; seuil:
            values_sep.append(paliers_mark())
        else:
            values_sep.append(sv[i])
    return values_sep</code></pre>
                    </details>
                </dd>
                <dt id="Sensorem_Beta-C.FonctionsSignal.sep_values2"><code class="name flex">
                    <span>def <span class="ident">sep_values2</span></span>(<span>sv)</span>
                </code></dt>
                <dd>
                    <div class="desc"><h2 id="parameters">Parameters</h2>
                        <dl>
                            <dt><strong><code>sv</code></strong> :&ensp;<code>TYPE,list</code></dt>
                            <dd>DESCRIPTION.
                                Liste de valeurs décimales, ayant la forme d'un signal carré ascendant puis descendant
                                (données expérimentales).
                            </dd>
                        </dl>
                        <pre><code class="language-python-repl">&gt;&gt;&gt; a = [0.0015  ,0.0015 ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0206 , 0.0779 , 0.1577 , 0.1747 , 0.1769 , 0.1675 , 0.1447 , 0.1294 , 0.1219 , 0.1193 , 0.1187 , 0.1179 , 0.1174 , 0.1175 , 0.1172 , 0.1168 , 0.1169 , 0.1165 , 0.1166 , 0.1167 , 0.1168 , 0.1173 , 0.1176 , 0.1168 , 0.1176 , 0.1172 , 0.1173 , 0.1171 , 0.1165 , 0.1172 , 0.1173 , 0.1174 , 0.1172 , 0.1175 , 0.1177 , 0.1172 , 0.1173 , 0.1173 , 0.1176 , 0.1178 , 0.1173 , 0.1174 , 0.1174 , 0.1172 , 0.1173 , 0.1173 , 0.1174 , 0.1173 , 0.1169 , 0.1171 , 0.1174 , 0.1171 , 0.1172 , 0.1173 , 0.1164 , 0.1164 , 0.1165 , 0.1164 , 0.1165 , 0.1168 , 0.1171 , 0.1172 , 0.1171 , 0.1172 , 0.1177 , 0.1175 , 0.1174 , 0.1176 , 0.1173 , 0.1173 , 0.1171 , 0.1171 , 0.1168 , 0.1167 , 0.1169 , 0.1169 , 0.1169 , 0.1171 , 0.1172 , 0.1173 , 0.2008 , 0.2177 , 0.2205 , 0.2219 , 0.2236 , 0.2237 , 0.2216 , 0.2217 , 0.2216 , 0.2225 , 0.2242 , 0.2231 , 0.2226 , 0.2233 , 0.2225 , 0.2228 , 0.2239 , 0.2239 , 0.2245 , 0.2231 , 0.2228 , 0.2233 , 0.2237 , 0.2238 , 0.2232 , 0.2228 , 0.2236 , 0.3808 , 0.4189 , 0.4319 , 0.4338 , 0.4339 , 0.4307 , 0.4313 , 0.4342 , 0.4319 , 0.4332 , 0.4333 , 0.4329 , 0.4358 , 0.4366 , 0.4353 , 0.4343 , 0.4343 , 0.4337 , 0.4341 , 0.4363 , 0.4318 , 0.4319 , 0.4322 , 0.4312 , 0.4334 , 0.4333 , 0.4334 , 0.4322 , 0.4359 , 0.4337 , 0.4319 , 0.4313 , 0.4325 , 0.4317 , 0.4313 , 0.4307 , 0.4318 , 0.4283 , 0.5441 , 0.6355 , 0.6491 , 0.6531 , 0.6504 , 0.6537 , 0.6538 , 0.6546 , 0.6529 , 0.6537 , 0.6538 , 0.6539 , 0.6539 , 0.6538 , 0.6539 , 0.6539 , 0.6539 , 0.6539 , 0.6534 , 0.6538 , 0.6539 , 0.6534 , 0.6535 , 0.6534 , 0.6525 , 0.6528 , 0.6529 , 0.6554 , 0.6558 , 0.6559 , 0.5521 , 0.4593 , 0.4364 , 0.4325 , 0.4279 , 0.4299 , 0.4287 , 0.4307 , 0.4308 , 0.4309 , 0.4311 , 0.4321 , 0.4328 , 0.4282 , 0.4285 , 0.4324 , 0.4331 , 0.4317 , 0.4328 , 0.4328 , 0.4313 , 0.4332 , 0.4321 , 0.4321 , 0.4351 , 0.4287 , 0.4336 , 0.4304 , 0.4318 , 0.4275 , 0.4271 , 0.4239 , 0.4237 , 0.4054 , 0.2998 , 0.2448 , 0.2449 , 0.2193 , 0.2205 , 0.2189 , 0.2175 , 0.2191 , 0.2197 , 0.2202 , 0.2194 , 0.2189 , 0.2184 , 0.2174 , 0.2179 , 0.2180 , 0.2179 , 0.2195 , 0.2194 , 0.2187 , 0.2211 , 0.2206 , 0.2207 , 0.2212 , 0.2205 , 0.2207 , 0.2208 , 0.2206 , 0.2204 , 0.2195 , 0.2209 , 0.2210 , 0.2203 , 0.2204 , 0.2116 , 0.1881 , 0.18 , 0.1771 , 0.1754 , 0.1606 , 0.1391 , 0.1261 , 0.1209 , 0.1192 , 0.1181 , 0.1181 , 0.1182 , 0.1178 , 0.1175 , 0.1176 , 0.1167 , 0.1179 , 0.1180 , 0.1174 , 0.1174 , 0.1177 , 0.1178 , 0.1176 , 0.1178 , 0.1172 , 0.1178 , 0.1177 , 0.1184 , 0.1182 , 0.1183 , 0.1184 , 0.1181 , 0.1173 , 0.0015 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0015 , 0.0017 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0009 , 0.0010 , 0.0011 , 0.0011 , 0.0011 , 0.0012 , 0.0009 , 0.0005 , 0.0007 , 0.0007 , 0.0005 , 0.0005 , 0.0008 , 0.0008 , 0.0007 , 0.0004 , 0.0005 , 0.0004 , 0.0004 , 0.0004 , 0.0009 , 0.0008 , 0.0009 , ]
</code></pre>
                        <h2 id="returns">Returns</h2>
                        <dl>
                            <dt><strong><code>values_sep</code></strong> :&ensp;<code>TYPE, list</code></dt>
                            <dd>DESCRIPTION. Pour le traitement d'un type de capteur (Mac Soufflerie)
                                La liste de sortie est l'identification des paliers par le remplacement de sa première
                                valeur par paliers_mark(). Une première boucle nettoie le signal des valeurs aberrantes
                                Dû à la mesure.
                                La deuxième boucle identifie les paliers
                            </dd>
                        </dl>
                        <pre><code class="language-python-repl">&gt;&gt;&gt; type(sep_values(a))
&lt;class 'list'&gt;
</code></pre>
                    </div>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">def sep_values2(sv):
    &#34;&#34;&#34;
    Parameters
    ----------
    sv : TYPE,list
        DESCRIPTION.
        Liste de valeurs décimales, ayant la forme d&#39;un signal carré ascendant puis descendant
        (données expérimentales).
    &gt;&gt;&gt; a = [0.0015  ,0.0015 ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015  ,0.0015  ,0.0015  ,0.0015  ,0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0015 , 0.0206 , 0.0779 , 0.1577 , 0.1747 , 0.1769 , 0.1675 , 0.1447 , 0.1294 , 0.1219 , 0.1193 , 0.1187 , 0.1179 , 0.1174 , 0.1175 , 0.1172 , 0.1168 , 0.1169 , 0.1165 , 0.1166 , 0.1167 , 0.1168 , 0.1173 , 0.1176 , 0.1168 , 0.1176 , 0.1172 , 0.1173 , 0.1171 , 0.1165 , 0.1172 , 0.1173 , 0.1174 , 0.1172 , 0.1175 , 0.1177 , 0.1172 , 0.1173 , 0.1173 , 0.1176 , 0.1178 , 0.1173 , 0.1174 , 0.1174 , 0.1172 , 0.1173 , 0.1173 , 0.1174 , 0.1173 , 0.1169 , 0.1171 , 0.1174 , 0.1171 , 0.1172 , 0.1173 , 0.1164 , 0.1164 , 0.1165 , 0.1164 , 0.1165 , 0.1168 , 0.1171 , 0.1172 , 0.1171 , 0.1172 , 0.1177 , 0.1175 , 0.1174 , 0.1176 , 0.1173 , 0.1173 , 0.1171 , 0.1171 , 0.1168 , 0.1167 , 0.1169 , 0.1169 , 0.1169 , 0.1171 , 0.1172 , 0.1173 , 0.2008 , 0.2177 , 0.2205 , 0.2219 , 0.2236 , 0.2237 , 0.2216 , 0.2217 , 0.2216 , 0.2225 , 0.2242 , 0.2231 , 0.2226 , 0.2233 , 0.2225 , 0.2228 , 0.2239 , 0.2239 , 0.2245 , 0.2231 , 0.2228 , 0.2233 , 0.2237 , 0.2238 , 0.2232 , 0.2228 , 0.2236 , 0.3808 , 0.4189 , 0.4319 , 0.4338 , 0.4339 , 0.4307 , 0.4313 , 0.4342 , 0.4319 , 0.4332 , 0.4333 , 0.4329 , 0.4358 , 0.4366 , 0.4353 , 0.4343 , 0.4343 , 0.4337 , 0.4341 , 0.4363 , 0.4318 , 0.4319 , 0.4322 , 0.4312 , 0.4334 , 0.4333 , 0.4334 , 0.4322 , 0.4359 , 0.4337 , 0.4319 , 0.4313 , 0.4325 , 0.4317 , 0.4313 , 0.4307 , 0.4318 , 0.4283 , 0.5441 , 0.6355 , 0.6491 , 0.6531 , 0.6504 , 0.6537 , 0.6538 , 0.6546 , 0.6529 , 0.6537 , 0.6538 , 0.6539 , 0.6539 , 0.6538 , 0.6539 , 0.6539 , 0.6539 , 0.6539 , 0.6534 , 0.6538 , 0.6539 , 0.6534 , 0.6535 , 0.6534 , 0.6525 , 0.6528 , 0.6529 , 0.6554 , 0.6558 , 0.6559 , 0.5521 , 0.4593 , 0.4364 , 0.4325 , 0.4279 , 0.4299 , 0.4287 , 0.4307 , 0.4308 , 0.4309 , 0.4311 , 0.4321 , 0.4328 , 0.4282 , 0.4285 , 0.4324 , 0.4331 , 0.4317 , 0.4328 , 0.4328 , 0.4313 , 0.4332 , 0.4321 , 0.4321 , 0.4351 , 0.4287 , 0.4336 , 0.4304 , 0.4318 , 0.4275 , 0.4271 , 0.4239 , 0.4237 , 0.4054 , 0.2998 , 0.2448 , 0.2449 , 0.2193 , 0.2205 , 0.2189 , 0.2175 , 0.2191 , 0.2197 , 0.2202 , 0.2194 , 0.2189 , 0.2184 , 0.2174 , 0.2179 , 0.2180 , 0.2179 , 0.2195 , 0.2194 , 0.2187 , 0.2211 , 0.2206 , 0.2207 , 0.2212 , 0.2205 , 0.2207 , 0.2208 , 0.2206 , 0.2204 , 0.2195 , 0.2209 , 0.2210 , 0.2203 , 0.2204 , 0.2116 , 0.1881 , 0.18 , 0.1771 , 0.1754 , 0.1606 , 0.1391 , 0.1261 , 0.1209 , 0.1192 , 0.1181 , 0.1181 , 0.1182 , 0.1178 , 0.1175 , 0.1176 , 0.1167 , 0.1179 , 0.1180 , 0.1174 , 0.1174 , 0.1177 , 0.1178 , 0.1176 , 0.1178 , 0.1172 , 0.1178 , 0.1177 , 0.1184 , 0.1182 , 0.1183 , 0.1184 , 0.1181 , 0.1173 , 0.0015 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0015 , 0.0017 , 0.0014 , 0.0014 , 0.0014 , 0.0014 , 0.0009 , 0.0010 , 0.0011 , 0.0011 , 0.0011 , 0.0012 , 0.0009 , 0.0005 , 0.0007 , 0.0007 , 0.0005 , 0.0005 , 0.0008 , 0.0008 , 0.0007 , 0.0004 , 0.0005 , 0.0004 , 0.0004 , 0.0004 , 0.0009 , 0.0008 , 0.0009 , ]

    Returns
    -------
    values_sep : TYPE, list
        DESCRIPTION. Pour le traitement d&#39;un type de capteur (Mac Soufflerie)
        La liste de sortie est l&#39;identification des paliers par le remplacement de sa première
        valeur par paliers_mark(). Une première boucle nettoie le signal des valeurs aberrantes
        Dû à la mesure.
        La deuxième boucle identifie les paliers
    &gt;&gt;&gt; type(sep_values(a))
    &lt;class &#39;list&#39;&gt;

    &#34;&#34;&#34;
    seuil = 0.5  # seuil de détection des changements de paliers
    sensibilite = 0.21  # seuil de nettoyage
    nb_values = len(sv)
    values_sep = list()  # Donne brute avec identification des étages
    nb_remplacement = 1

    for i in range(nb_values - abs(nb_remplacement) - 5):
        if abs(sv[i + 5] - sv[
            i]) &lt; sensibilite:  # attention le i+x (5) est à mettre en accord avec les valeurs d&#39;exclusion des moyenne et ecartype du pdf et de l&#39;interface graphique
            sv[i] = sv[i]
        else:
            sv[i] = sv[i - nb_remplacement]

    for i in range(nb_values - 1):
        if abs(sv[i + 1] - sv[i]) &gt; seuil or abs(sv[i] - sv[i + 1]) &gt; seuil:
            values_sep.append(paliers_mark())
        else:
            values_sep.append(sv[i])
    return values_sep</code></pre>
                    </details>
                </dd>
                <dt id="Sensorem_Beta-C.FonctionsSignal.traitement_general_donnees"><code class="name flex">
                    <span>def <span class="ident">traitement_general_donnees</span></span>(<span>paliers_find, paliers_find2, values_sep_paliers, values_sep_paliers2, entete)</span>
                </code></dt>
                <dd>
                    <div class="desc"><p>Calcule les moyennes et écart-types pour remplir les tabs -
                        Sert à la fois à l'affichage dans le GUI et à la génération de pdf
                        Merci Bruno</p></div>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">def traitement_general_donnees(paliers_find, paliers_find2, values_sep_paliers, values_sep_paliers2, entete):
    &#34;&#34;&#34;Calcule les moyennes et écart-types pour remplir les tabs -
    Sert à la fois à l&#39;affichage dans le GUI et à la génération de pdf
    Merci Bruno
    &#34;&#34;&#34;

    moyenne = list([&#34;&#34;] * paliers_find)
    moyenne2 = list([&#34;&#34;] * paliers_find2)
    ecartype = list([&#34;&#34;] * paliers_find)
    ecartype2 = list([&#34;&#34;] * paliers_find2)
    donneestraitees2 = [[&#34;0&#34;] * len(entete)] * paliers_find
    #
    if len(range(paliers_find)) == len(range(paliers_find2)):
        #
        for i, j in zip(range(paliers_find), range(paliers_find2)):
            #
            moyenne[i] = mean(values_sep_paliers[i][
                              7: -7])  # Correction, suppression des valeurs de début et de fin pour les traitements.
            ecartype[i] = pstdev(values_sep_paliers[i][7: -7]) * 1000
            #
            if values_sep_paliers2[j][7: -7]:
                # moyenne2[j] = mean(values_sep_paliers2[i][7: -7])  #BGU: ancienne formulation bizarre
                # ecartype2[j] = pstdev(values_sep_paliers2[i][7: -7])  #BGU: ancienne formulation bizarre
                moyenne2[j] = mean(values_sep_paliers2[j][7: -7])
                ecartype2[j] = pstdev(values_sep_paliers2[j][7: -7])
            else:
                moyenne2[j] = 0
                ecartype2[j] = 0
            donneestraitees2[i] = (str(round(moyenne[i], 4)), str(round(ecartype[i], 4)), str(round(moyenne2[j], 4)),
                                   str(round(ecartype2[j], 4)))
            # donneestraitees2[i] = (str(round(moyenne[j],4)),str(round(ecartype2[i],4)), str(round(moyenne2[i],4)),str(round(ecartype[j],4))) #BGU: ancienne formulation bizarre
            # Attention il y a une inversion, une mauvais attribuation des valeurs ecartype 2 correspond au premier capteur ?
            #
    else:
        for i in range(paliers_find):
            moyenne[i] = mean(values_sep_paliers[i][
                              7: -7])  # Correction, supression des valeurs de début et de fin pour les traitements.
            ecartype[i] = pstdev(values_sep_paliers[i][7: -7]) * 1000
            donneestraitees2[i] = (&#39;Oups&#39;, str(round(moyenne[i], 4)), str(round(ecartype[i], 4)), &#34;Oups&#34;)
    return donneestraitees2</code></pre>
                    </details>
                </dd>
                <dt id="Sensorem_Beta-C.FonctionsSignal.traitement_signal"><code class="name flex">
                    <span>def <span class="ident">traitement_signal</span></span>(<span>data)</span>
                </code></dt>
                <dd>
                    <div class="desc"><p>Fonction générale qui appel les traitements des données, pour le capteur à
                        raccorder</p></div>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">def traitement_signal(data):
    &#34;&#34;&#34;Fonction générale qui appel les traitements des données, pour le capteur à raccorder

    &#34;&#34;&#34;
    # identification des paliers
    values_sep = sep_values(data)
    paliers_find, plage_len_find, nb_values, values_sep = info_values(values_sep)
    paliers = make_paliers(paliers_find, plage_len_find)
    values_sep_paliers = paliers_values_sep(values_sep, nb_values, paliers)
    return values_sep_paliers, data, values_sep, paliers_find</code></pre>
                    </details>
                </dd>
                <dt id="Sensorem_Beta-C.FonctionsSignal.traitement_signal2"><code class="name flex">
                    <span>def <span class="ident">traitement_signal2</span></span>(<span>data)</span>
                </code></dt>
                <dd>
                    <div class="desc"><p>TBC</p></div>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">def traitement_signal2(data):
    &#34;&#34;&#34;
    TBC
    &#34;&#34;&#34;
    # identification des paliers
    values_sep = sep_values2(data)
    paliers_find, plage_len_find, nb_values, values_sep = info_values(values_sep)
    paliers = make_paliers(paliers_find, plage_len_find)
    values_sep_paliers = paliers_values_sep(values_sep, nb_values, paliers)
    return values_sep_paliers, data, values_sep, paliers_find</code></pre>
                    </details>
                </dd>
                <dt id="Sensorem_Beta-C.FonctionsSignal.version"><code class="name flex">
                    <span>def <span class="ident">version</span></span>(<span>)</span>
                </code></dt>
                <dd>
                    <div class="desc"><p>Retourne le numéro de version du logiciel</p></div>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">def version():
    &#34;&#34;&#34;Retourne le numéro de version du logiciel
    &#34;&#34;&#34;
    # definition et passage du numéro de version du traitement
    # version = str(&#34; (0.4.3 Bêta_c)&#34;)
    return str(&#34; (0.4.3 Bêta_c)&#34;)</code></pre>
                    </details>
                </dd>
            </dl>
        </section>
        <section>
        </section>
    </article>
    <nav id="sidebar">
        <h1>Index</h1>
        <div class="toc">
            <ul></ul>
        </div>
        <ul id="index">
            <li><h3>Super-module</h3>
                <ul>
                    <li><code><a href="index.html" title="Sensorem_Beta-C">Sensorem_Beta-C</a></code></li>
                </ul>
            </li>
            <li><h3><a href="#header-functions">Functions</a></h3>
                <ul class="">
                    <li><code><a href="#Sensorem_Beta-C.FonctionsSignal.gen_nom_paliers"
                                 title="Sensorem_Beta-C.FonctionsSignal.gen_nom_paliers">gen_nom_paliers</a></code></li>
                    <li><code><a href="#Sensorem_Beta-C.FonctionsSignal.info_values"
                                 title="Sensorem_Beta-C.FonctionsSignal.info_values">info_values</a></code></li>
                    <li><code><a href="#Sensorem_Beta-C.FonctionsSignal.isol_capteurs"
                                 title="Sensorem_Beta-C.FonctionsSignal.isol_capteurs">isol_capteurs</a></code></li>
                    <li><code><a href="#Sensorem_Beta-C.FonctionsSignal.make_paliers"
                                 title="Sensorem_Beta-C.FonctionsSignal.make_paliers">make_paliers</a></code></li>
                    <li><code><a href="#Sensorem_Beta-C.FonctionsSignal.paliers_mark"
                                 title="Sensorem_Beta-C.FonctionsSignal.paliers_mark">paliers_mark</a></code></li>
                    <li><code><a href="#Sensorem_Beta-C.FonctionsSignal.paliers_values_sep"
                                 title="Sensorem_Beta-C.FonctionsSignal.paliers_values_sep">paliers_values_sep</a></code>
                    </li>
                    <li><code><a href="#Sensorem_Beta-C.FonctionsSignal.prep_donnees_graph"
                                 title="Sensorem_Beta-C.FonctionsSignal.prep_donnees_graph">prep_donnees_graph</a></code>
                    </li>
                    <li><code><a href="#Sensorem_Beta-C.FonctionsSignal.readColCSV"
                                 title="Sensorem_Beta-C.FonctionsSignal.readColCSV">readColCSV</a></code></li>
                    <li><code><a href="#Sensorem_Beta-C.FonctionsSignal.readColCSV1"
                                 title="Sensorem_Beta-C.FonctionsSignal.readColCSV1">readColCSV1</a></code></li>
                    <li><code><a href="#Sensorem_Beta-C.FonctionsSignal.sep_values"
                                 title="Sensorem_Beta-C.FonctionsSignal.sep_values">sep_values</a></code></li>
                    <li><code><a href="#Sensorem_Beta-C.FonctionsSignal.sep_values2"
                                 title="Sensorem_Beta-C.FonctionsSignal.sep_values2">sep_values2</a></code></li>
                    <li><code><a href="#Sensorem_Beta-C.FonctionsSignal.traitement_general_donnees"
                                 title="Sensorem_Beta-C.FonctionsSignal.traitement_general_donnees">traitement_general_donnees</a></code>
                    </li>
                    <li><code><a href="#Sensorem_Beta-C.FonctionsSignal.traitement_signal"
                                 title="Sensorem_Beta-C.FonctionsSignal.traitement_signal">traitement_signal</a></code>
                    </li>
                    <li><code><a href="#Sensorem_Beta-C.FonctionsSignal.traitement_signal2"
                                 title="Sensorem_Beta-C.FonctionsSignal.traitement_signal2">traitement_signal2</a></code>
                    </li>
                    <li><code><a href="#Sensorem_Beta-C.FonctionsSignal.version"
                                 title="Sensorem_Beta-C.FonctionsSignal.version">version</a></code></li>
                </ul>
            </li>
        </ul>
    </nav>
</main>
<footer id="footer">
    <p>Generated by <a href="https://pdoc3.github.io/pdoc"
                       title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>